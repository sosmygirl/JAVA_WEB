# Java 方法重载，方法重写（覆盖），继承等细节注意

## 1.方法重载（method overload）的具体规范

如果有两个方法的方法名相同，但参数不一致，那么可以说一个方法是另一个方法的重载。
一.方法名一定要相同。
二.方法的参数表必须不同，包括参数的类型或个数，以此区分不同的方法体。
1.如果参数个数不同，就不管它的参数类型了！
2.如果参数个数相同，那么参数的类型或者参数的顺序必须不同。
三.方法的返回类型、修饰符可以相同，也可不同。
四.main方法也可以被重载
方法重载的作用：可以一个相同的方法传入不同的参数以达到想要的结果
 

## 2.方法继承：利用extends关键字一个方法继承另一个方法，而且只能直接继承一个类。

 
一.当Sub类和Base类在同一个包时Sub类继承Base类中的public/protected/默认级别的变量个方法
备注：在不同包时继承public/protected级别的变量和方法。
方法继承的作用可以提高代码的重用性和安全性
3.Java中的不同包中的访问权限
1,public 2,protected 3,(default) 4,private
1任何类都可以访问
2在同一个包中的所有类可以访问,以及该类的子类
3同一个包中的所有类
4只能在本类中访问

## 3、方法覆盖（method override）：如果在子类中定义一个方法，其名称、返回类型及参数签名正好与父类中某个方法的名称、返回类型及参数签名相匹配，那么可以说，子类的方法覆盖了父类的方法。
- 子类的方法名称返回类型及参数签名 必须与父类的一致
- 子类方法不能缩小父类方法的访问权限
-  子类方法不能抛出比父类方法更多的异常
- 方法覆盖只存在于子类和父类之间，同一个类中只能重载
- 父类的静态方法不能被子类覆盖为非静态方法
- 子类可以定义于父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法（满足覆盖约束），    
-             而且Java虚拟机把静态方法和所属的类绑定，而把实例方法和所属的实例绑定。
- 父类的非静态方法不能被子类覆盖为静态方法
- 父类的私有方法不能被子类覆盖
- 父类的抽象方法可以被子类通过两种途径覆盖（即实现和覆盖）
- 父类的非抽象方法可以被覆盖为抽象方法
## 4、Super关键字：super和this关键字都可以用来覆盖Java语言的默认作用域，使被屏蔽的方法或变量变为可见。
- 父类的成员变量和方法为private使用super访问编译出错
- 在类的构造方法种，通过super语句调用这个类的父类的构造方法
- 在子类种访问父类的被屏蔽的方法和属性
- 只能在构造方法或实例方法内使用super关键字，而在静态方法和静态代码块内不能使用super
## 5、多态：
- 对于一个引用类型的变量，Java编译器按照它的声明的类型来处理
- 对于一个引用类型的变量，运行时Java虚拟机按照它的实际引用的对象来处理
- 运行时环境中，通过引用类型变量来访问所引用对象的方法和属性时，Java虚拟机采用以下绑定规则

            1）实例方法与引用变量实际引用的对象的方法绑定，属于动态绑定
            2）静态方法与引用变量所声明的类型的方法绑定，属于静态绑定
            3）成员变量（包括静态和实例变量）与引用变量所声明的类型的成员变量绑定，属于静态绑定    
备注：上转型对象

上转型对象具有如下特点: 
1)上转型对象不能操作子类新增的成员变量(失掉了这部分属性),不能使用子类新增的方法(失掉了一些功能). 
2)上转型对象可以操作子类继承或隐藏的成员变量,也可以使用子类继承的或重写的方法. 
3)上转型对象操作子类继承或重写的方法时,就时通知对应的子类对象去调用这些方法.因此,如果子类重写了父类的某个方法后,对象的上转型对象调用这个方法时,一定是调用了这个重写的方法. 
4)可以讲对象的上转型对象再强制转换到一个子类的对象,这时,该子类对象又具备了子类的所有属性和功能.（也就是下溯）
概括就是上转型对象用的是父类的变量和方法，子类只能重写（覆盖）父类的方法，因为是动态绑定的
       
作用：多态有编译时多态 和运行时多态。
第一个是通过方法重载实现；第二个是通过方法覆盖实现（子类覆盖父类方法）。
第一种就是我们调用方法是不用区分参数类型，程序会自动执行相应方法，如： 加法运算，可以使int相加，可以是double相加，都是同一个方法名。
第二种就是动态绑定，使用父类引用指向子类对象，再调用某一父类中的方法时，不同子类会表现出不同结果。 这样的作用就是扩展性极好，玩过网游的话应该知道 游戏中有不同的角色，它们都有一个父类，它们做相同动作时表现出来的效果就会不一样，比如跑，魔法师的跑跟战士的跑就不会一样，这就是俩者都覆盖了父类中的跑方法，各自有自己的现实，表现出来多态。 如果有一天你想再加个角色，只用再写一个类继承该父类，覆盖其中的跑方法就行了，其他代码不用怎么改，所以可维护性也很好。                                                                                                 
 

## 6、继承的利弊和使用原则：
- 集成数的层次不可太多
- 集成数的上层为抽象层

            （1）定义了下层子类都用友的相同属性和方法，并且尽可能默认实现，从而提高重用性
            （2）代表系统的接口，描述系统所能提供的服务

- 继承关系最大的弱点：打破封装
- 精心设计专门用于被继承的类

            （1）对这些类必须提供良好的文档说明
            （2）尽可能的封装父类的实现细节，把代表时间细节的属性和方法定义为private类型
            （3）如果某些实现细节必须被子类访问，定义为protected类型
            （4）把不允许子类覆盖的方法定义为final类型
            （5）父类的构造方法不允许调用可被子类覆盖的方法
            （6）如果某些类不是专门为了继承而设计，那么随意继承它是不安全的

